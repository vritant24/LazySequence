using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace LazySequence
{
    /// <summary>
    /// A class that allows you to lazily and asynchronously generate elements
    /// of a sequence that can be iterated on with access to additional state.
    /// </summary>
    /// <typeparam name="T">The type of element in the sequence.</typeparam>
    public class AsyncLazySequence<T> : IAsyncEnumerable<T>
    {
        private readonly GetNextElementDelegateAsync getNextElementAsync;
        private readonly T firstElement;

        /// <summary>
        /// Delegate to asynchronously generate next element in the sequence.
        /// </summary>
        /// <param name="previousElement">Previous element in the sequence.</param>
        /// <param name="nextIndex">Index of element to be generated by this delegate.</param>
        /// <returns>
        /// A <see cref="Task"/> that resolves to a <see cref="Tuple"/> of:
        /// <list type="number">
        /// <item>The next element in the sequence.</item>
        /// <item>A bool to indicate whether the returned element is the last element.</item>
        /// </list>
        /// </returns>
        public delegate Task<(T nextElement, bool isLastElement)> GetNextElementDelegateAsync(
            T previousElement, ulong nextIndex);

        /// <summary>
        /// Creates <see cref="AsyncLazySequence{T}"/>
        /// </summary>
        /// <param name="firstElement">The first element of the sequence.</param>
        /// <param name="getNextElementAsync">
        /// <see cref="GetNextElementDelegateAsync"/>
        /// </param>
        public static IAsyncEnumerable<T> Create(
            T firstElement,
            GetNextElementDelegateAsync getNextElementAsync)
        {
            firstElement = firstElement
                ?? throw new ArgumentNullException(nameof(firstElement));
            getNextElementAsync = getNextElementAsync
                ?? throw new ArgumentNullException(nameof(getNextElementAsync));

            return new AsyncLazySequence<T>(firstElement, getNextElementAsync);
        }

        private AsyncLazySequence(
            T firstElement,
            GetNextElementDelegateAsync getNextElementAsync)
        {
            this.firstElement = firstElement;
            this.getNextElementAsync = getNextElementAsync;
        }

        #region IAsyncEnumerable
        /// <summary>
        /// Lazily and asynchronously iterates on the sequence.
        /// </summary>
        /// <returns>Enumerator that can be iterated on.</returns>
        public async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var isCompleted = false;
            T? currentElement = this.firstElement;
            ulong indexOfCurrentElement = 0;

            while (!isCompleted)
            {
                cancellationToken.ThrowIfCancellationRequested();

                yield return currentElement;

                indexOfCurrentElement++;
                (currentElement, isCompleted) = await
                    this.getNextElementAsync(currentElement, indexOfCurrentElement);
            }
        }
        #endregion
    }
}
